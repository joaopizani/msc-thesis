\chapter{Introduction}
\label{chap:intro}
    Several factors have been causing an increasing demand for hardware acceleration of algorithms,
    and there is also pressure to reduce the duration and cost of the circuit design process.
    These trends collide with the techniques and tooling used in the hardware design process,
    which have not experienced the same evolution as the ones for software development.

    \acrodef{ASIC}{Application-Specific Integrated Circuit}
    The design of an \ac{ASIC} imposes strong requirements,
    specially with regards to correctness (functional and otherwise).
    Design mistakes which make their way into the manufacturing process can be very expensive,
    and errors that reach the consumer even more, as there's no such thing as "updating" a chip.
    One infamous example of such a bug reaching the consumer was the \emph{FDIV} bug in Intel's Pentium chip,
    which might have costed the company over 400 million dollars~\cite{intel-fdiv}.

    In the software industry, and specially
    in application domains requiring high correctness assurance (such as information security, machine control, etc.),
    functional programming techniques have long been used to improve productivity
    and reduce the need for extensive testing and debugging.
    Advocates of functional programming claim productivity gains of up to 10 times to
    programmers coming from an imperative environment.

    Another advantage usually attributed to functional programming is an increased capacity to
    \emph{reason} about your programs, specially to perform what is called \emph{equational reasoning}.
    These claims have been confirmed in practice (and still keep getting more confirmations),
    and furthermore, functional techniques and constructs keep "penetrating" imperative languages
    with each new release. For example, the SWIFT language, released by Apple in 2014,
    includes features such as immutable data structures, first-class functions and type inference.

    % TODO: Purely functional programming examples

    In a certain way, we can compare the power of the tools and techniques
    used nowadays in hardware design to the early days of software development.
    Of course there are inherent and fundamental differences between the two activities, but
    this comparison leads us to ask whether ideas from programming language research,
    specially those related to functional programming, could be used to improve hardware design.

    \acrodef{EDSL}{Embedded Domain-Specific Language}
    Research trying to answer this broad question started already in the 1980s,
    with the work of Prof. Mary Sheeran and others~\cite{sheeran-survey},
    developing \emph{functional} hardware description languages, such as \emph{μFP}.
    Later, a trend emerged of developing \acp{EDSL} for hardware description,
    \emph{hosted} in functional languages, such as Haskell.
    Prominent examples of this trend are the Lava~\cite{lava-1999} family,
    as well as ForSyDe~\cite{forsyde1999}.

    \acrodef{DTP}{Dependently-Typed Programming}
    Staying on the "path" of functional programming but going further in type system power we reach \ac{DTP}.
    A type system with \emph{dependent types} can express strong properties about the programs written in it.
    In fact, a dependent type can represent any formula of \emph{intuitionistic first-order logic} and,
    according to the \emph{Curry-Howard correspondence},
    inhabitants of a type correspond to proofs of the logical statement represented by the type.

    Therefore, using dependent types,
    one can more easily approximate \emph{specification} and \emph{implementation}.
    The type signature of a function can give much more \emph{guarantees} about its behaviour.
    A classical example when introducing \ac{DTP} is the type of sized vectors,
    along with the safe ``head'' function, as depicted in listing \ref{lst:sized-vec}
    \begin{listing}[h]
        \ExecuteMetaData[agda/latex/Report/ChapterIntroduction.tex]{Vect-head}
        \caption{(Natural) sized vectors and the safe head function. \label{lst:sized-vec}}
    \end{listing}

    We can have, for example, the type of a "vector grouping" function as in listing \ref{lst:group-decl}.
    \begin{listing}[h]
        \ExecuteMetaData[agda/latex/Report/ChapterIntroduction.tex]{group-decl}
        \caption{Signature of a vector grouping function, with dependent types. \label{lst:group-decl}}
    \end{listing}

    The return type of this function reads as:
    \begin{quote}
        There is a vector \texttt{xss} of size \texttt{n}
        (whose elements are of size \texttt{k}), such that \texttt{concat xss ≡ xs}.
    \end{quote}

    Therefore, it returns a collection of groups "sliced" from the original vector, with the requested size.
    Additionally, it returns a proof that concatenating all groups results in the original vector.
    This type serves as a \emph{specification of correctness} for the function.
    Any function with this type is, by definition, a \emph{correct "grouping" function}.

    %% Only for deep-embedded
    In an \ac{EDSL} for hardware there will usually be a \emph{type} whose elements are circuits.
    One can imagine that it would be useful to design this type
    in such a way that as few of its elements as possible are \emph{malformed}.
    Therefore, we also want to make the typing of the circuits as strong as possible,
    to eliminate as many classes of design mistakes as possible.

    %% TODO: Tie up motivation here

    Depedent type systems allow us to easily express several of these \emph{well-formedness} rules for circuits.
    One simple criterion of circuit \emph{well-formedness} is, for example, that it contains no ``floating'' signals.
    That is, all of a circuit's internal components must have all their ports connected. % TODO: to something?

    \begin{figure}[h]
        \centerline{\includegraphics[width=0.5\textwidth]{imgs/floating-wire.pdf}}
        \caption{TODO: floating wire diagram \label{fig:floating-wire}}
    \end{figure}

    In this M.Sc thesis, we developed a hardware \ac{EDSL} -- Π-Ware -- which enforces this and other
    well-formedness rules using dependent types.
    Π-Ware is a \emph{deep-embedded} \ac{EDSL} hosted in the Agda programming language,
    that supports synthesis to (VHDL) netlists and simulation for combinational and synchronous sequential circuits.
    Furthermore, the user of Π-Ware can prove \emph{expressive} properties about circuits in the logic
    of Agda itself (intuitionistic first-order logic).

    %% TODO: describe chapter/section contents?

    \begin{itemize}
        \item Research question, methodology
        \begin{itemize}
            \item In which way can dependent types make circuit design a more precise and efficient activity?
            \item We develop an EDSL for hardware - Π-Ware - embedded in the DT language Agda
            \begin{itemize}
                \item Characteristics of Π-Ware:
                \begin{itemize}
                    \item Deep-embedded
                    \item Synthesis to netlists
                    \item Simulation semantics
                    \item Low AND high level of data abstraction
                    \item Prove STRONG properties (first-order logic) about circuit behaviour interactively
                \end{itemize}
            \end{itemize}
        \end{itemize}
    \end{itemize}
