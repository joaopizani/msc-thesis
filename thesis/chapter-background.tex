\chapter{Background}
\label{chap:hardware}

    \section{Hardware Description}
    \label{sec:hardware-description}
        %% TODO
        %% Target models of computation: register machine x boolean circuits
        %%     trade-off in complexity (size x cycles)
        %% General trend to raise the level of abstraction of descriptions
        %% Hardware description languages

        The hardware development process can be well understood by analyzing its
        similarities and differences to software development.
        Both hardware and software development usually "begin" with a high-level \emph{specification}
        of the algorithm to be implemented.
        Also, both proceed by a series of translations, increasingly adding more details to the description.

        However, the final targets of both hardware and software development differ:
        while in software the final artifact is machine code (sequence of instructions) for some architecture,
        in hardware the target is usually a \emph{floorplan}, a spacially placed graph of logic gates and wires.

        Also, the transformation steps in the software and hardware chains are different,
        as depicted in figure~\ref{fig:sw-hw-chains}.
        In this figure, the rectangular boxes represent transformations steps towards a more detailed description,
        while the ellipsoid shapes represent artifacts that are consumed/produced by each step.

        \begin{figure}[h]
            \centerline{\includegraphics[width=0.95\textwidth]{imgs/sw-hw-chains.pdf}}
            \caption{Software and Hardware refinement chains. \label{fig:sw-hw-chains}}
        \end{figure}

        \acrodef{HDL}{Hardware Description Language}
        \acrodef{RTL}{Register-Transfer Level}
        The first (higher) levels in the hardware implementation flow are usually described using
        so-called \acp{HDL}, most popularly Verilog and \acs{VHDL}.
        Nowadays they are used by hardware engineers to write both behavioural specifications of circuits
        (topmost ellipsis in figure~\ref{fig:sw-hw-chains}) as well as \ac{RTL} descriptions.
        However, these languages were originally designed for \emph{simulation} purposes,
        and there are several problems that arise when using them to
        model hardware \emph{architecture} at \ac{RTL} level.

        First of all, only a \emph{subset} of these languages can be used for \emph{synthesis}
        (actually deriving a netlist and floorplan).
        Although there is a standard defining a \emph{synthesizable subset} of \acs{VHDL}~\cite{ieee1076-3-synth-vhdl},
        tools differ greatly in the level of support.
        To further complicate the matter, this synthesizable subset is not syntactically seggregated.
        One example of complex requirement for \acs{VHDL} to be synthesizable is:
        "in a process, every output must be assigned a value for every possible combination of input values".
        In listing~\ref{lst:vhdl-unsynth-process} we have an example process violating this requirement.

        \begin{listing}[h]
            \begin{center}
                \vhdlfile{code/vhdl-unsynth-process.vhd}
            \end{center}
            \caption{Unsynthesizable \acs{VHDL} process \label{lst:vhdl-unsynth-process}}
        \end{listing}

        Still on the differences between software and hardware development,
        another important aspect is the level of \emph{automatization} in the chains (fig.~\ref{fig:sw-hw-chains}):
        usually, all transformation steps in the software chain are automatic.
        On the hardware chain the \emph{crucial} ``Architectural design'' step is manual.

        The complex task of making explicit the space-time tradeoff lays in the hands of the hardware designer:
        she has to decide how much parallelism to use, how to pipeline the processing steps of the algorithm,
        taking care to not generate data hazards, etc.

        \acrodef{HLS}{High-Level Synthesis}
        Recently, tools have been developed for this first step -- called \ac{HLS}.
        They usually take \emph{behavioural \acs{VHDL}}, C or even C++ as input, and produce \ac{RTL} code.
        However, current \acs{HLS}-based hardware implementation chains still face two main problems:

        \begin{itemize}
            \item The input language (VHDL, C) is not expressive enough.
            \item Specification, verification and synthesis are all done with different tools and different languages.
            \begin{itemize}
                \item Even behavioural \acs{VHDL} can be considered practically a different language
                    than \acl{RTL} \acs{VHDL}.
            \end{itemize}
        \end{itemize}

        Functional programming languages have been touted as a solution to both of these problems.
        A functional program is a more abstract and expressive specification of an algorithm than
        a C function or VHDL entity.
        Also, functional languages could be used to \emph{both} write the specification of a circuit's behaviour,
        as well as it's \acl{RTL} description.


    \section{Functional Hardware Description}
    \label{sec:functional-hardware}
        In the beginning of the 1980s, many researchers were trying to use functional programming languages
        to design and reason about hardware circuits.
        These developments were happening at the same time when \ac{VHDL} was being designed and standardized.

        The idea was then to come up with new functional languages, \emph{specialized} to do hardware description.
        One of the prominent early examples in this set is μFP~\cite{mufp-1984},
        which was in turn inspired by John Backus's FP~\cite{backus-turing-lecture}.
        In contrast to \ac{VHDL}, which was later adapted in a non-standardized way to synthesis,
        μFP was designed since the beginning to have both interpretations:

        \begin{description}
            \item[Behavioural]
                Each "primitive" circuit as well as each combining form (higher-order function)
                has an attached \emph{functional semantics}, used in simulation.
            \item[Geometric]
                Each combining form has a typical geometric interpretation.
                For example, sequential composition of two circuits \AB{c₁} and \AB{c₂} will result
                in a floorplan in which \AB{c₂} is placed "adjacent to" \AB{c₁} and connected to it
                by the required wires.
        \end{description}

        The μFP language was an \emph{extension} of Backus's FP, and contained only one extra combining form.
        This μ combining form was responsible for the creation of functions (circuits) with internal state.
        According to the original μFP paper~\cite{mufp-1984}:

        \begin{quote}
            The meaning of μf is defined in terms of the meaning of f.
            The functional ``out'' hides the state
            so that while $M(f)$ maps a sequence of input-state pairs to a sequence of output-state pairs,
            $\text{out}(M(f))$ just maps a sequence of inputs to a sequence of outputs.
            For a given cycle, the next output and the next state depend on the current input and the current state.
        \end{quote}

        One very simple example of a circuit with internal state is a shift register.
        In figure~\ref{fig:mufp-shift}, we can see the structure of this circuit.
        Each of the dotted boxes represent a μFP expression.
        The smaller box denotes a combinational circuit (with 2 inputs and 2 outputs) that swaps its inputs.
        The bigger box corresponds to the application of the μ combinator to the smaller one.
        It adds internal state in the form of the indicated latch, creating a feedback loop.

        \begin{figure}[h]
            \centerline{\includegraphics[width=0.5\textwidth]{imgs/mufp-shift.pdf}}
            \caption{\emph{Shift register}: a simple example of sequential circuit in μFP. \label{fig:mufp-shift}}
        \end{figure}

        By being a conservative extension of Backus's FP,
        almost all algebraic laws that hold for FP also hold for μFP.
        Furthermore, the μ combining form has useful algebraic laws of its own.

        The most notable of these laws states that the composition of two ``μ-wrapped'' functions
        can be converted to one single ``μ-wrapper''.
        In other words, a circuit with several, localized, memory elements can be converted into a circuit
        with one ``centralized'' memory bank and a combinational block.
        If we apply this rewrite rule from right to left, we can see it as a form of ``optimization'',
        in which we start with a single memory bank and refine the design towards one in which
        memory elements sit closer to the sub-circuits that actually use them.

        Two of the core ideas of μFP served as inspiration for Π-Ware:

        \begin{description}
            \item[Double interpretation] As μFP, circuits in Π-Ware have two distinct semantics:
                they can be simulated (functional semantics) or synthesized to a netlist (geometric semantics).
            \item[Single sequential constructor] As in μFP, there is only \emph{one way} in Π-Ware
                to construct a sequential circuit.
                Also, the same law regarding the ``state-introducing'' constructor holds in Π-Ware,
                but because we use Agda as host language, this meta-theoretical property can be proven
                \emph{in the same language} in which circuits are described.
        \end{description}


        \subsection{Embedded Functional Hardware Description}
        \label{subsec:embedded-functional-hardware}
            % General context, history
            \acrodef{EHDL}{Embedded Hardware Description Language}
            With the growing popularity and advocacy~\cite{hudak-edsls} of the concept of \emph{embedded} \acp{DSL},
            a trend emerged of also having embedded \acp{HDL}.
            Functional programming languages were a natural fit for hosting \acp{DSL}.
            In particular, the Haskell programming language proved to be a popular choice of host,
            due to features such as lazy evaluation, highly-customizable and overloadable syntax.

            Some examples of highly-successful \acp{DSL} implemented in Haskell are:

            \begin{itemize}
                \item Attoparsec~\footnote{\url{https://github.com/bos/attoparsec}} (monadic parsing)
                \item Accelerate~\footnote{\url{https://github.com/AccelerateHS/accelerate/wiki}} (regular data-parallel computing)
                \item Esqueleto~\footnote{\url{https://github.com/prowdsponsor/esqueleto}} (SQL queries)
                \item Diagrams~\footnote{\url{http://projects.haskell.org/diagrams/}} (2D and 3D vector graphics)
            \end{itemize}

            Also, some of the most popular and powerful \acp{EHDL} are hosted by Haskell.
            Let us now present some of these \acp{EHDL} and discuss their problems,
            which will lead to the question of to solve them using dependent types.

            \subsubsection{Lava}
            Perhaps the most popular family of hardware \acp{DSL} embedded in Haskell is the \emph{Lava} family.
            Lava's first incarnation~\cite{lava-1999} was developed at Chalmers University of Technology
            and Xilinx, and used a shallow-embedding in Haskell, along with a monadic description style
            to handle naming and sharing.
            These circuit monads were parameterized, and by using different typeclass instances,
            different interpretations could be given to a single circuit description, such as
            simulation, synthesis, or model checking.

            The design of Lava suffered significant changes later on, abandoning the monadic interface
            and adopting an observable sharing solution based on a form of reference equality~\cite{observable-sharing-circuits}.
            Currently, Lava has several dialects, such as \emph{Chalmers-Lava}, \emph{Xilinx-Lava}, \emph{York-Lava} and \emph{Kansas-Lava}.
            We base our examples in \emph{Chalmers-Lava}~\footnote{\url{https://hackage.haskell.org/package/chalmers-lava2000}},
            which can be said to be the ``canonical'' dialect, and also the most actively developed.

            In Lava, circuits are written as normal Haskell functions, by using pattern matching,
            function application and local naming. One extra restriction is that the types of the arguments are
            constructed by the \texttt{Signal} type constructor.
            For example, a negation gate in Lava would have the following type signature:

            \begin{haskellcode}
        inv :: Signal Bool -> Signal Bool
            \end{haskellcode}

            Another restriction is that all circuit inputs must be ``uncurried'', i.e,
            even though the \emph{circuit} has several inputs, the \emph{function} modeling that circuit
            must have only one argument, with all inputs in a \emph{tuple}.
            A \texttt{NAND} gate in Lava would look like this:

            \begin{haskellcode}
        nand2 :: (Signal Bool, Signal Bool) -> Signal Bool
        nand2 (a, b) = inv (and2 (a, b))
            \end{haskellcode}

            Finally, due to the instances provided for the \texttt{Signal} type, the only way to
            ``aggregate'' bits in Lava is by using tuples and lists.
            Using only these structures we forego some type safety that Haskell provides.
            For example, an n-bit binary (ripple-carry) adder is Lava has the following description:

            \begin{haskellcode}
        adder :: (Signal Bool, ([Signal Bool], [Signal Bool])) -> ([Signal Bool], Signal Bool)
        adder (carryIn, ([] ,[]))    = ([], carryIn)
        adder (carryIn, (a:as, b:bs) = (sum:sums, carryOut)
            where
                (sum, carry)     = fullAdd (carryIn, (a, b))
                (sums, carryOut) = adder (carry, (as, bs))
            \end{haskellcode}

            In this circuit description, there is an \emph{expectation} that both inputs have the same size.
            In fact, if they are not, then a \emph{run-time} error will occur, during simulation.
            This because the given definition is \emph{partial}: the cases
            for \texttt{(carryIn, ([], b:bs))} and \texttt{(carryIn, (a:as, []))} are left undefined.

            This limitation of Lava can be solved by dependent types, namely by using statically-sized vectors.
            Another limitation of Lava is related to the way in which it solves the observable sharing question:
            in order to detect sharing and cycles, the equality over the \texttt{Signal} type is defined
            as an equality over the references used.
            Therefore, comparisons of signals that were ``created'' in different sites will fail,
            even though their values are the same.
            For example, the following expressions will evaluate to \texttt{False}:

            \begin{haskellcode}
        test1 :: Bool
        test1 = low == low

        test2 :: Bool
        test2 = simulate adder (low, ([low], [low])) == low
            \end{haskellcode}

            This limitation is also not present in Π-Ware, due to the way in which we describe circuits
            in a structural fashion, avoiding having to deal with observable sharing.

            \subsubsection{Hawk}


            % ForSyDe


    \section{Dependently-Typed Programming}
    \label{sec:dtp}

        \subsection{Type systems}
        \label{subsec:type-systems}
            A type system, in the context of programming languages,
            serves the purpose of grouping values, so that "meaningless" and potentially undesirable operations are avoided.
            For example, it would be silly to add an integer number and a character string.
            In fact, it is hard to imagine an addition operation accepting such arguments and having nice algebraic properties.
            To define addition sensibly, therefore, we need the help of a type system,
            to "ban" all programs that would try to add these "incompatible" values.

            Type systems can have very different properties and be implemented in very different ways.
            Some of the ways in which type systems can be categorized are~\cite{understanding-types-cardelli}:

            \begin{itemize}
                \item Weak vs. strong
                \item Static vs. dynamic
                \item Polymorphism (parametric, ad-hoc, subtyping)
            \end{itemize}

            %% TODO: the "road to" dependent types. GIVE EXAMPLES AT EACH STEP
            The most basic form of abstraction -- values depending on values (the concept of functions) -- is
            supported in practically all type systems.
            The result of functions can also depend on the \emph{types} of the arguments
            (this is called \emph{polymorphism}).

            In \emph{parametric polymorphism}, functions are written without mentioning any specific type,
            and can therefore be applied to any instantiation of the type variable.
            A typical example of a parametric polymorphic function is obtaining the length of a list,
            where the same definition works for any type of element in the list.
            Now in \emph{ad-hoc polymorphism}, the behaviour of a function varies with the type of the inputs.
            In Haskell ad-hoc polymorphism is implemented in the type class system.
            A typical example of an ad-hoc polymorphic function would be a comparison-based sorting algorithm,
            in which depending on the type of the elements in the collection,
            different comparison operators will be used.

            Polymorphism adds \emph{expressivity} and makes a type system stronger,
            in the sense that it allows for more precise specifications.
            For example, if we want to implement a ``swap'' function for pairs in Haskell,
            we could do start by specifying the type of the function in a non-polymorphic way:
            \begin{haskellcode}
        swap' :: (Int , Int) -> (Int , Int)
            \end{haskellcode}

            There are several definitions satisfying the above type which do not swap the elements.
            For example, one ``wrong'' implementation would output a constant pair:
            \begin{haskellcode}
        swap' _ = (1 , 1)
            \end{haskellcode}

            Notice how the argument is ignored (we use the ``don't care'' pattern).
            To \emph{rule out} this class of wrong implementations, we could make the type polymorphic:
            \begin{haskellcode}
        swap'' :: (a , a) -> (a , a)
            \end{haskellcode}

            Now any ``constant'' definition will \emph{not anymore fit the type specified}.
            This because the only way to get an element of the \emph{polymorphic type} \texttt{a}
            is to use what is in the parameter passed to the function.
            However, we could still write a wrong function with this type, namely the identity:
            \begin{haskellcode}
        swap'' (x , y) = (x , y)
            \end{haskellcode}

            This is possible because our type does not \emph{yet} reflect a precise enough specification of \texttt{swap}.
            On the type we have now, the types of both elements in the pair are the same.
            If we lift this artificial restriction, we get the type signature which \emph{fully specificies} \texttt{swap}.
            \begin{haskellcode}
        swap :: (a , b) -> (b , a)
            \end{haskellcode}

            Now, \emph{any definition with this type} is a correct definition of swap.
            Because of the way in which we use type variables (\texttt{a} and \texttt{b}) in the signature,
            there is only one possible implementation of \texttt{swap}:
            \begin{haskellcode}
        swap (x , y) = (y , x)
            \end{haskellcode}

            Going one step further, some type systems support types that depend on other types, these are
            called \emph{type operators} or \emph{type-level functions}.
            In Haskell, this form of abstraction is implemented as regular parameterized type constructors
            (\texttt{List}, \texttt{Maybe}, etc.) and as \emph{indexed type families}.

            The last step then in our ``ladder'' of type system expressiveness is \emph{dependent types}.

        \subsection{Dependent types}
        \label{subsec:dependent-types}

            A \emph{dependent type} is a type that depends on a value.
            A typical example of dependent type is the type of \emph{dependent pairs},
            in which the \emph{type} of the second element depends on the \emph{value} of the first:
            \begin{listing}[h]
                \ExecuteMetaData[agda/latex/Report/ChapterBackground.tex]{Pair}
            \end{listing}

            In a dependent type system, we can also have functions in which the return \emph{type}
            depends on the \emph{value} of a parameter.
            These functions belong to the so-called \emph{dependent function space}.

            For example, we can imagine having a \AF{take} function for vectors which makes use
            of this possibility to have a more precise specification.
            First of all, when indexing or obtaining a prefix from a vector,
            we need to ensure that the the index (or amount to be extracted) is within bounds.
            That is, we cannot \AF{take} more elements than the size of the vector.

            To achieve this goal, we define a datatype (\AD{Fin} \AB{n}) of natural numbers smaller than \AB{n}.
            \begin{listing}[h]
                \ExecuteMetaData[agda/latex/Report/ChapterBackground.tex]{Fin}
            \end{listing}

            With this definition, \AD{Fin} \AN{0} is a type with no elements,
            while \AD{Fin} \AN{1} has 1 element (\AI{zero}),
            \AD{Fin} \AN{2} has 2 elements (\AI{zero} and \AI{suc} \AI{zero}), and so forth\ldots
            Thus, the elements of \AD{Fin} \AB{n} correspond to natural numbers smaller than \AB{n}.

            Now, having defined the \AD{Fin} \AB{n} datatype, we can write the type signature for \AF{take}:
            \begin{listing}[h]
                \ExecuteMetaData[agda/latex/Report/ChapterBackground.tex]{take-decl}
                \caption{A ``safe'' prefix-taking function for sized vectors. \label{lst:take-decl}}
            \end{listing}

            On the signature of \AF{take}, dependent types are used both to restrict the \emph{domain}
            ($ k \leq n $) and to express a desired property of the \emph{result}
            (length of the returned vector should be \AB{k}).
            Finally, we observe that the type of \AF{take} is not a \emph{sufficient condition} for
            what we would intuitively conceive as being a ``correct'' prefix-taking function.
            There are ``wrong'' implementations which still would have this type, for example
            returning a constant vector of size \AB{k}.
            This type is, however, provides many more \emph{static guarantees}:
            All implementations violating bounds and producing incorrectly-sized results
            are ruled out \emph{by the type checker at compile-time}.

            Until now, we have approached languages with dependent types as a way to help with \emph{programming}.
            Specificaly, we gave examples on how using dependent types in function's type signatures
            can rule out incorrect implementations \emph{by design}.
            Dependently-typed languages can also be seen from a \emph{logical} point of view.

            This remark -- that a programming language (with it's type system) can also be seen as a logic --
            goes back to the early days of computing, and is known by several names,
            among which ``Curry-Howard isomorphism'' and ``propositions as types''~\cite{propositions-as-types}.
            It initially was ``discovered'' as a connection between the simply-typed lambda calculus
            and intuitionistic propositional logic.
            As decades went by, this correspondence was found to be much more general,
            and several connections were drawn between diverse typed lambda calculi and logics.

            The system of dependent types which we use in this thesis (the one used by \emph{Agda})
            corresponds to \emph{intuitionistic predicate logic}.

            %% TODO: what intuitionistic predicate logic means?

            Even though there are logics connected to other -- less powerful -- typed lambda calculi,
            the one used in Agda is expressive enough to radically improve its area of use.
            In a language with dependent types, we can not only write \emph{programs}, but also \emph{proofs}.

            For example, in Agda, we can model the less-than-or-equal order relation using an
            \emph{indexed data family}~\ref{lst:nat-le}, where the indices are the usual Peano naturals.

            \begin{listing}[h]
                \ExecuteMetaData[agda/latex/Report/ChapterBackground.tex]{nat-le}
                \caption{Order relation ($\le$) over naturals, as an \emph{Agda} indexed data family.
                    \label{lst:nat-le}}
            \end{listing}

            Having defined this relation, we can prove several useful properties of it:
            for example, the fact~(\ref{lst:le-trans}) that this relation is transitive.

            \begin{listing}[h]
                \ExecuteMetaData[agda/latex/Report/ChapterBackground.tex]{le-trans}
                \caption{Proof that the $\le$ relation is transitive. \label{lst:le-trans}}
            \end{listing}

            As proofs are first-class citizens, they can be passed as arguments to functions, and
            returned as well.
            This provides yet another powerful way of expressing requirements of function arguments,
            and showing that the result returned satisfies some desired property.

            For example, we have already shown (in listing~\ref{lst:take-decl}) how to have a ``safe''
            version of a prefix-taking function for statically-sized arrays:
            by using a specially-designed type for the desired amount.
            Now we have another way to express the same requirement:
            we can explicitly require a proof argument be passed,
            guaranteeing that the amount to be ``taken'' is \emph{less than or equal} to the array size.

            \begin{listing}[h]
                \ExecuteMetaData[agda/latex/Report/ChapterBackground.tex]{take-proof-decl}
            \end{listing}

            This capability for precisely defining and enforcing requirements and invariants make
            dependently-typed programming languages natural candidates for hosting \acp{EDSL}.
            In the paper ``The power of Pi''~\cite{power-pi}, three examples are shown of how to
            embed \acp{DSL} in Agda and get corresponding \emph{Domain-Specific Type Systems}
            equipped with desirable properties ``for free''.

            The examples in ``The power of Pi'' -- specially the embedding of \emph{Cryptol},
            a low-level cryptographic \ac{DSL} -- served as inspiration,
            and lead us to investigate how dependently-typed programming can benefit hardware
            design, the main question targeted by this project.

            %% TODO: introduce Barendregt's cube, recapitulate and name properly the type systems.
            %% TODO: introduce logical interpretations for the cube's systems, Martin-Löf, etc.
            % \begin{figure}[h]
            %     \centerline{\includegraphics[width=0.5\textwidth]{imgs/lambda-cube.pdf}}
            %     \caption{Barendregt's "Lambda Cube" \label{fig:lambda-cube}}
            % \end{figure}


        \subsection{Hardware and dependent types}
        \label{sec:hardware-dtp}

            %% TODO
            %% Others
            %% Coquet
            %%     Turning design mistakes into TYPE ERRORS
            %%     Proving properties about circuit behaviour
            %%         Functional correctness in particular.
