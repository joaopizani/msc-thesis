\chapter{The Π-Ware library}
\label{chap:piware}

    Π-Ware is an \ac{EHDL} that allows for circuit description (modelling),
    simulation, reasoning (proving correctness or other properties), and synthesis to netlists.
    In this chapter we will describe in detail how the Π-Ware library is organized,
    what principles are behind some of the most important design decisions taken in its development,
    and how to use Π-Ware to model, simulate and reason about circuit behaviour.

    The reader is assumed to be familiar with the \emph{Agda} programming language,
    as this is the language in which Π-Ware is embedded.
    An introductory-level knowledge of dependent type theory in general is also appreciated.


    \section{Circuit Syntax}
    \label{sec:circuit-syntax}
        %% Shallow vs. deep embedding
        %%     Chose deep because of synthesis and non-functional analyses
        %% Structural modelling
        %%     Represent connections among circuits in the DSL, \emph{not in the metalanguage}
        %%     Avoid having to deal with observable sharing

        The most basic activity allowed by Π-Ware is the \emph{description} of circuits:
        as already mentioned briefly in the introduction, Π-Ware is \emph{deeply} embedded,
        which means there is a \emph{datatype} whose values are circuits.

        A deep embedding was chosen in order to allow for semantics other than execution (simulation).
        Particularly, the possibility of \emph{synthesizing} circuit models was a requirement
        kept in mind throughout the whole development.

        The circuit datatype (\AD{ℂ'}) is the most \emph{fundamental} of the whole library.
        It is defined as an dependent inductive family, indexed by two natural numbers,
        as shown in listing~\ref{lst:Circuit-core}.

        \begin{listing}[h]
            \ExecuteMetaData[agda/latex/PiWare/Circuit/Core.tex]{Circuit-core}
            \caption{The core circuit type (\AD{ℂ'}) of Π-Ware. \label{lst:Circuit-core}}
        \end{listing}

        The indices of \AD{ℂ'} represent, respectively, the \emph{size} of the circuit's input and output.
        The \emph{size} of a circuit input or output port can be thought of
        as the number of ``wires'' entering (resp. leaving) that circuit.
        This notion will become much more concrete in section~\ref{sec:circuit-semantics}, with
        a detailed presentation of the simulation semantics.

        To better understand the reasoning behind the design of the \AD{ℂ'} datatype,
        its constructors can be considered to belong to one of three categories:

        \begin{description}
            \item[Fundamental] These construct ``predefined'', or ``atomic'' circuits, as they have no sub-circuits.
                \begin{itemize}
                    \item \AI{Nil}: The \emph{empty circuit}. Performs no computation and has neither inputs nor outputs.
                        Even so it is useful as a ``base case'' when building large circuits with recursive definitions.
                    \item \AI{Gate}: Builds one of the \emph{predefined} circuits, given by a \emph{gate library}
                        passed as a parameter to the \AM{Circuit} module.
                \end{itemize}

        \end{description}

        \subsection{Design discipline enforced by circuit constructors}
            The several constructors of \AD{ℂ'} ``calculate'' the port sizes of the circuits they construct,
            based on the sizes of the circuits given as arguments.
            These calculations implement \emph{structural well-formedness} rules for circuits.
            One example of such rule can be seen in the case of parallel composition (\AI{\_|'\_}),
            where the input (resp. output) size of the composed circuit equals the \emph{sum}
            of the input (resp. output) sizes of the constituent sub-circuits.
            Together, all of these rules ensure:

            \begin{description}
                \item[No floating wires] Circuit sizes need to match in order for the usage of a constructor
                    to be type-correct
                \item [NO short-circuits] The \AI{Plug} constructor, the only one which can be used for
                    ``rewiring'' purposes, has a type which forbids mapping two sources to the same load.
            \end{description}


    \section{Abstraction Mechanisms}
    \label{sec:circuit-abstraction}
        \begin{itemize}
            \item Data abstraction (atom vectors x arbitrary synthesizable types)
                \subitem Atom (enumeration axioms)
                \subitem Word / Synthesizable
                    \subsubitem Proof search?
            \item Gate abstraction (Technology primitives x Semantic fundamentals)
                \subitem Circuits descriptions are parameterized by a set of fundamental gates
                    \subsubitem Always combinational
                    \subsubitem Their correctness is assumed
                \subitem For synthesis, still need to give these gates a description in terms of technology primitives
        \end{itemize}

        \subsection{Gate library}
        \label{subsec:gate-library}


    \section{Circuit Semantics}
    \label{sec:circuit-semantics}
        Functional semantics for simulation\ldots

        \begin{itemize}
            \item Two types of evaluation: combinational and sequential
            \item Combinational eval requires a proof that the circuit contains no loops
                \subitem Eval of a fundamental gate is just its \emph{definitional behaviour}

            \item For sequential circuits we use a \emph{causal stream semantics}
            %% TODO: couldn't we restrict it even more and just keep ONE PAST VALUE in the context?
                \subitem Current output depends on the current input and (possibly) on the past input
                \subitem \emph{Different} than plain Stream functions

            \item There's also an eval function which allows the circuit to be viewed as function from Stream to Stream
        \end{itemize}

        \subsection{Combinational evaluation}
        \label{subsec:combinational-eval}

        \subsection{Sequential evaluation}
        \label{subsec:sequential-eval}
            Initially we tried to write a semantics yielding simply a function over streams.

            But this is not quite a good semantic model for a synchronous sequential circuits,
            as a stream function is allowed to ``look into future values'' in order to produce
            the output stream, while a sequential circuit can only use information about its past inputs
            when calculating the next output.

            Therefore, causal streams\ldots

            \subsubsection{Causal Streams}
