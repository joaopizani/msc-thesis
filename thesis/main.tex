\documentclass[a4paper]{article}

\usepackage{fontspec}
\setmonofont[Scale=0.8]{DejaVu Sans Mono}

\usepackage{unicode-math}
\usepackage{amsmath}
\usepackage{mathtools}
\usepackage{hyperref}  % ref
\usepackage{color}
\usepackage{booktabs}  % nice tables
\usepackage{float}
\usepackage{acronym}


%% Code
\usepackage{minted}
\usepackage{fancyvrb}
\usemintedstyle{default}

\newmint{haskell}{mathescape,fontfamily=tt}
\newmintedfile{haskell}{mathescape,fontfamily=tt}
\newminted{haskell}{gobble=8,mathescape,fontfamily=tt}
\newmint{coq}{mathescape,fontfamily=tt}
\newmintedfile{coq}{mathescape,fontfamily=tt}
\newminted{coq}{gobble=8,mathescape,fontfamily=tt}



%% Metainformation
%% PDF stuff
\usepackage{datetime}
\usepackage{ifpdf}
\ifpdf
\pdfinfo{
    /Author (João Paulo Pizani Flor)
    /Title (PiWare: An Embedded Hardware Description Language using Dependent Types)
    /Keywords (EDSL, HDL, Hardware Description, Functional Programming, Dependent types, Agda, Coq, Lava, Coquet)
    /CreationDate (D:\pdfdate)
}
\fi

\title{Π-Ware: An Embedded Hardware Description Language using Dependent Types}

\date{\today}

\author{
    João Paulo Pizani Flor \\
    Department of Information and Computing Sciences, \\
    Utrecht University - The Netherlands \\
    e-mail: j.p.pizaniflor@students.uu.nl
}



%% The document itself
\begin{document}

    \maketitle


    \section{Introduction}
    \label{sec:intro}
        %% MAKE A STRONG CASE AS MOTIVATION

        Several factors have been causing an increasing demand for hardware acceleration of algorithms,
        and there is also pressure to reduce the duration and cost of the circuit design process.
        These trends collide with the techniques and tooling used in this activity, which are,
        compared to the ones observed in software development, primitive.

        % Hardware is harder :)  Stronger correctness requirements, verification, validation

        One of the (long-running) trends to increase productivity in the software industry
        is the usage of functional programming.
        Advocates of functional programming claim productivity gains of up to 10 times to
        programmers coming from an imperative environment.
        Another advantage usually attributed to functional programming is an increased capacity to
        \emph{reason} about your programs, specially to perform what is called \emph{equational reasoning}.
        These claims have been confirmed in practice (and still keep getting more confirmations),
        and furthermore, functional techniques and constructs keep "penetrating" imperative languages
        with each new release. % TODO: mention C++11, SWIFT, etc.

        % TODO: Purely functional programming examples

        In a certain way, we can compare the level of abstraction in which hardware design and verification
        is performed nowadays with software development in its early age.
        Of course there are inherent and fundamental differences between the two activities, but
        this comparison leads us to ask whether current research ideas from PL technology,
        and specially those related to functional programming, could be used to improve hardware design.

        Research trying to answer this broad question started already in the 1980s,
        with the work of Prof. Mary Sheeran and others,
        developing \emph{functional} hardware description languages, such as μFP.
        Later, a trend emerged of developing \emph{Embedded} Domain-Specific Languages (EDSLs)
        for hardware description, \emph{hosted} in functional languages, such as Haskell.
        % TODO: Lava, ForSyDe, etc. ALREADY KINDA PRACTICALLY VALIDATED AND USED

        Staying on the "path" of functional programming but going even further in power we reach
        Dependently-Typed Programming (DTP).
        A type system with \emph{dependent types} can express very powerful properties
        about the programs written in it.
        In fact, a dependent type can express any formula of \emph{intuitionistic first-order logic} and,
        according to the \emph{Curry-Howard correspondence},
        inhabitants of a type are proofs for the statement that the type represents.

        What this means is that, using dependent types, one can more easily approximate \emph{specification} and \emph{implementation}.
        The type signature of a function can say much more about the behaviour of such function.
        We can have, for example, the type of a "vector grouping" function as follows:

        %% TODO: vector grouping

        This function returns a collection of groups "sliced" from the original vector, with the requested size.
        Additionally, the return type proves that concatenating the groups results in the original vector.
        This type therefore serves as a \emph{specification of correctness} for the function.
        Any function with this type is, by definition, a \emph{correct "grouping" function}.

        In an EDSL for hardware there will usually be a \emph{type} whose elements are circuits
        One can imagine that it would be useful to design this type in such a way that as few of its elements as possible are ``wrong''.
        Such circuits would be "correct-by-design", for a certain definition of correctness.
        Therefore, we also want to make the typing of the circuits as strong as possible,
        to eliminate as many classes of design mistakes as possible.

        %% TODO: Tie up motivation here, summarize a bit

        \begin{itemize}
            \item Research question, methodology
            \begin{itemize}
                \item In which way can dependent types make circuit design a more precise and efficient activity?
                \item We develop an EDSL for hardware - Π-Ware - embedded in the DT language Agda
                \begin{itemize}
                    \item Characteristics of Π-Ware:
                    \begin{itemize}
                        \item Deep-embedded
                        \item Synthesis to netlists
                        \item Simulation semantics
                        \item Low AND high level of data abstraction
                        \item Prove STRONG properties (first-order logic) about circuit behaviour interactively
                    \end{itemize}
                \end{itemize}
            \end{itemize}
        \end{itemize}


    \section{Hardware Design}
    \label{sec:hardware}
        \begin{itemize}
            \item Compare software and hardware
            \item Models of computation: turing machine, lambda calculus, boolean circuits
                \subitem trade-off in complexity (size x cycles)

            \item General trend to raise the level of abstraction of descriptions
            \item Hardware description languages

            \item Attempts at High-Level Synthesis and so forth (TCC)
        \end{itemize}

        \subsection{Functional Hardware Description}
        \label{subsec:functional-hardware}
            \begin{itemize}
                \item Embedded functional HDLs
                \item Lava, etc.
            \end{itemize}


    \section{Depdendently-Typed Programming}
    \label{sec:dtp}

        \subsection{Dependent types}
        \label{subsec:dependent-types}
            \begin{itemize}
                \item General type system explanation, growing in power until we reach dependent types
                \item Expressivity of dependent types
                    \subitem Curry-Howard correspondence
                    \subitem Practical examples
                        \subsubitem Especially powerful for EDSLs (The Power of Pi)
                        \subsubitem Segway into circuit EDSLs
            \end{itemize}

            A type system, in the context of computer programming,
            serves the purpose of grouping values, so that "meaningless" and potentially undesirable operations are avoided.
            For example, it would be silly to add an integer number and a character string.
            In fact, it is hard to imagine an addition operation accepting such arguments and having nice algebraic properties.
            To define addition sensibly, therefore, we need the help of a type system, to "ban" all programs that would
            try to add these "incompatible" values.

            Type systems can have very different properties and be implemented in very different ways.
            Some of the ways in which type systems can be categorized are:
            \begin{itemize}
                \item Weak vs. strong
                \item Static vs. dynamic
                \item Polymorphism (which form)
                \item Etc.
            \end{itemize}
            %% TODO: cite old general types paper from the TPT seminar

        \subsection{Hardware and dependent types}
        \label{subsec:hardware-dtp}
            \begin{itemize}
                \item Others
                \item Coquet
                    \subitem Turning design mistakes into TYPE ERRORS
                    \subitem Proving properties about circuit behaviour
                    \subsubitem Functional correctness in particular.
            \end{itemize}


    \section{The Π-Ware library}
    \label{sec:piware}
        Lorem ipsum\ldots

        %% How to present:
            %% By design decisions ∨

        \subsection{Circuit Syntax}
        \label{subsec:circuit-types}
            \begin{itemize}
                \item Shallow vs. deep embedding
                    \subitem Chose deep because of synthesis and non-functional analyses
                \item Structural modelling
                    \subitem Represent connections among circuits in the DSL, \emph{not in the metalanguage}
                    \subitem Avoid having to deal with observable sharing
            \end{itemize}

        \subsection{Abstraction Mechanisms}
        \label{subsec:abstraction}
            \begin{itemize}
                \item Data abstraction (atom vectors x arbitrary synthesizable types)
                    \subitem Atom (enumeration axioms)
                    \subitem Word / Synthesizable
                        \subsubitem Proof search?
                \item Gate abstraction (Technology primitives x Semantic fundamentals)
                    \subitem Circuits descriptions are parameterized by a set of fundamental gates
                        \subsubitem Always combinational
                        \subsubitem Their correctness is assumed
                    \subitem For synthesis, still need to give these gates a description in terms of technology primitives
            \end{itemize}

        \subsection{Circuit Semantics}
        \label{subsec:eval-seq}
            \begin{itemize}
                \item Two types of evaluation: combinational and sequential
                \item Combinational eval requires a proof that the circuit contains no loops
                    \subitem Eval of a fundamental gate is just its \emph{definitional behaviour}

                \item For sequential circuits we use a \emph{causal stream semantics}
                %% TODO: couldn't we restrict it even more and just keep ONE PAST VALUE in the context?
                    \subitem Current output depends on the current input and (possibly) on the past input
                    \subitem \emph{Different} than plain Stream functions

                \item There's also an eval function which allows the circuit to be viewed as function from Stream to Stream
            \end{itemize}


    \section{Conclusions}
    \label{sec:conclusions}
        Lorem ipsum dolor amet\ldots


    \newpage
    \bibliographystyle{plain}
    \bibliography{references}

\end{document}
