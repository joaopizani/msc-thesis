\chapter{Discussion and related work}
\label{chap:discussion-related-work}

    The goals of Π-Ware and the techniques used in the library were very much inspired by the
    \acp{EDSL} already mentioned in Sections~\ref{subsec:embedded-functional-hardware}
    and~\ref{sec:hardware-dtp}, some of which were more deeply studied in a project
    predating this thesis.

    In this chapter we provide an overviwe of Π-Ware's features by means of example circuits and
    drawing comparisons with related work.

    \section{Functional hardware \acp{EDSL}}
    \label{sec:discussion-functional}

        \subsubsection{μFP}
        Π-Ware is a \emph{deep}-embedded \ac{DSL}, and was made so in order to allow for multiple
        interpretations or \emph{semantics} of circuits.
        The mapping between Π-Ware circuits and different semantics is similar to the behaviour
        of μFP~\cite{mufp-1984}.
        Each constructor of Π-Ware's low-level circuit datatype (\AD{ℂ'}) corresponds to two
        semantics, as in μFP: the \emph{simulation} semantics and the \emph{synthesis} semantics.
        Even though μFP is not embedded, and therefore does not have "circuit constructors" as
        (deep) \acp{EDSL} would have, we can still relate μFP's composition to Π-Ware's sequencing,
        μFP's tupling to Π-Ware parallel composition and so forth, keeping the analogy.

        There is a fundamental difference in what regards the \emph{synthesis} semantics of Π-Ware
        and μFP: the synthesis semantics of μFP prescribes a \emph{floorplan}, while Π-Ware synthesis
        only specifies a \emph{netlist}.
        A \emph{netlist} is a directed graph with logic gates as nodes and signals (wires) as edges.
        Producing a \emph{floorplan} goes one (slight) step further, by specifying relative
        physical positions between the components, such as "besides", "adjacent to", etc.
        In Π-Ware's case, it is the job of \emph{other} tools in the implementation chain to take
        Π-Ware's generated \ac{VHDL} as input and perform placement and routing.

        A last idea from μFP which inspired Π-Ware greatly was the definition of a
        single operator capable of introducing \emph{state} into circuits.
        It is also the only way to introduce loops in circuits.
        This construct is called the "μ combining form" in μFP, and actually gave the language its name,
        as μFP is an extension of Backus's FP~\cite{backus-turing-lecture} with exactly this one
        extra combining form.

        The Π-Ware equivalent of μ is called the \AI{DelayLoop} constructor, but it works in exactly the same way:
        given a combinational circuit, it "loops" part of the output back into that circuit's input,
        passing it through a memory element (a \emph{clocked latch}).
        Being the \emph{only} way to introduce loops, it also ensures that circuits contain no
        \emph{combinational loops}.

        The example of a shift register – with its μFP geometrical semantics shown in
        Figure~\ref{fig:mufp-shift} – has the following equivalent description in Π-Ware:

        \begin{center}
            \ExecuteMetaData[code/agda/latex/PiWare/Samples/BoolTrioSeq.tex]{shift}
        \end{center}

        When simulated, this circuit produces an output stream in which the tail is a copy of the
        input stream and the head is an "undefined" \AD{Atom} (the \AD{Atom} indexed by \AI{zero}).
        The output stream can be said to be "shifted" by one clock cycle, thus the circuit's name.

        Making use of dependent types, Π-Ware "tags" circuits with information on whether or not
        they have cycles (and thus state).
        In this way, \emph{combination simulation} (which disregards past inputs) only happens
        when a circuits is \emph{provably} cycle-free.

        \subsubsection{Lava}
        From Lava~\cite{observable-sharing-circuits} Π-Ware borrowed the idea of \emph{connection patterns}.
        Connection patterns are functions that, given a circuit or circuits,
        produce a larger, more powerful circuit by connecting its arguments in a certain \emph{pattern}.
        Usually these connection patterns are parameterized by a \emph{size} parameter,
        and are defined by induction on it.

        One example in Lava of such a connection pattern is \mintinline{haskell}{compose},
        the sequential composition of a series of circuits.
        The code for \mintinline{haskell}{compose} is shown on Listing~\ref{lst:lava-compose}.

        \begin{listing}[h]
            \centering{
                \begin{haskellcode}
        compose [] inp = inp
        compose (circ : circs) = out
            where
                x = circ inp
                out = compose circs x
                \end{haskellcode}
            }
            \caption{Lava's \mintinline{haskell}{compose} connection pattern.\label{lst:lava-compose}}
        \end{listing}

        And for comparison, Π-Ware's version of it (named \AF{seqs'}) is shown in Listing~\ref{lst:seqs-core}.

        \begin{listing}[h]
            \centering{\ExecuteMetaData[code/agda/latex/PiWare/Patterns/Core.tex]{seqs-core}}
            \caption{Π-Ware's version of the \texttt{compose} connection pattern.\label{lst:seqs-core}}
        \end{listing}

        Even though the \AF{seqs'} is written by using a fold on the vector of circuits and
        Lava's \mintinline{haskell}{compose} uses explicit recursion, the behaviour of both is the same:
        they connect the given circuit in series, i.e.,
        with the output of circuit $n$ connected to the input of circuit $n+1$.
        It is important to notice, however, how Π-Ware uses an \emph{explicit} sequential combination
        operator in the fold (\AI{\_⟫'\_}), while Lava uses Haskell's own function application syntax for
        this – the output of the first circuit in the list (\mintinline{haskell}{x = circ inp})
        is fed to the remainder of the "chain".

        In Lava's \mintinline{haskell}{compose}, an ordinary Haskell \texttt{List} is used
        as the collection of circuits to be connected.
        Therefore, as Haskell's lists are homogeneous, all of its elements – in this case,
        all of the circuits to be combined – must have the \emph{same type}.
        Using Agda, this unnecessary constraint imposed upon the collection of circuits could
        be lifted, and a more general pattern achieved.

        The minimum requirement to connect a collection of circuits in series is that their \emph{interfaces match},
        i.e., the output of circuit $n$ has the same size as the input of circuit $n+1$.
        The \AM{PiWare.Patterns} module is still very much a work-in-progress,
        and therefore such a generalized sequencing pattern is not yet implemented,
        but we expect that the concept of \emph{typed lists} as defined in a paper by
        McKinna and Wright~\cite{typed-stack-safe-compiler} will be useful to capture this notion of
        \emph{constrained} heterogeneous list.

        Moving away from connection patters, one aspect in which Π-Ware improves significantly
        upon Lava is the \emph{size checking} of circuits.
        As already mentioned briefly in Section~\ref{subsec:embedded-functional-hardware},
        Lava's usage of Haskell lists to express generically-sized circuit definitions leaves some
        mistakes undetected.

        For example, in the case of a generically-sized adder, the two inputs are expected to be
        of the \emph{same size}, but the \texttt{List} type cannot provide this guarantee,
        thus if mismatching inputs are provided, the error will only be detected at runtime.
        Notice how in the example Lava definition of a binary adder,
        the case with input lists of mismatching sizes is left undefined, making a runtime error possible:

        \begin{haskellcode}
        adder :: (Signal Bool, ([Signal Bool], [Signal Bool]))
              -> ([Signal Bool], Signal Bool)

        adder (carryIn, ([] ,[]))    = ([], carryIn)
        adder (carryIn, (a:as, b:bs) = (sum:sums, carryOut)
            where (sum, carry)     = fullAdd (carryIn, (a, b))
                  (sums, carryOut) = adder (carry, (as, bs))
        \end{haskellcode}

        In contrast, Π-Ware makes use of dependent types and has its circuit type (\AD{ℂ'})
        \emph{indexed by the size} of circuit inputs and outputs, thus enforcing these constraints easily.
        In Listing~\ref{lst:ripple} is an example of a ripple-carry added modelled in Π-Ware.
        Notice how the.

        \begin{listing}[h]
            \centering{\ExecuteMetaData[code/agda/latex/PiWare/Samples/RippleCarry.tex]{ripple}}
            \caption{Example of a ripple-carry adder modelled in Π-Ware.\label{lst:ripple}}
        \end{listing}

        Possibility to use \emph{high-level}, Agda types to model and simulate circuits.
        In contrast, Lava's circuit descriptions are essentially untyped.
        There in only a choice between
        %% TODO: lava low-level vs. Π-Ware high-level

        \subsubsection{ForSyDe}


    \section{Dependently-Typed Hardware \acp{EDSL}}

    % Lava similarities
    %     Deep embedded
    %     Synthesis and simulation
    %     Kinda same idea of connection patterns?
    % Lava differences
    %     No model checking output – no need as there's native proving using Agda
    %     Proofs can be written for statements regarding whole families of circuits (for all sizes, etc)
    %     High-level layer of types instead of just Bools, lists and tuples

    % ForSyDe similarities
    %     Deep embedded
    %     Uses statically-sized vectors (just an emulation of dependent types)
    %     Simulation and synthesis (synthesis to hierarchical VHDL)
    % ForSyDe differences
    %     No facilities to reason about and prove circuit properties
    %     Π-Ware only deals with the synchronous model of computation

    % Coquet
    %     Circuit type with same structure
    %     Sizes instead of more structures types as indices
    %     Coquet's general types hard to synthesize
    %         Elaborate example
    %     Elaborate over semantics of sequential circuits
    %     (DelayLoop vs. Delay, Coquet not synthesizing loops, etc.)

